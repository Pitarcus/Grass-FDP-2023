// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GrassGenerator

// --------------------------- PARAMETERS ----------------------

// Data structure for the outputbuffer
struct GrassData
{
    float3 position;
    float3 scale;
};

AppendStructuredBuffer<GrassData> _GrassData;

// Local to world matrix
//float4x4 _LocalToWorld;

uint _Size; // The size of the chunk of grass on the terrain
uint _rootSize; // Size of the root quadtree

uint _Resolution;   // Amount of blades in each axis
uint rootResolution;

float _Step;    // Distance between each blade

float _NodePositionX;
float _NodePositionY;

float _OffsetXAmount;
float _OffsetYAmount;

// Texture with the positions of the grass
Texture2D<float4> _PositionMap;
SamplerState sampler_PositionMap;

SamplerState my_linear_repeat_sampler;
SamplerState my_linear_clamp_sampler;

// Height displacement stuff
Texture2D<float4> _HeightMap;
SamplerState sampler_HeightMap;

int heightmapWidth;
int heightmapHeight;

int heightmapSampleOffsetX;
int heightmapSampleOffsetY;

float _HeightDisplacementStrenght;


//RWStructuredBuffer<uint> _ArgsBuffer;


// ---------------------------- FUNCTIONS -------------------------


// Random generator
float rand(float2 co) 
{
    return(frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453)) * 1;
}

[numthreads(16,16,1)]
void GrassGenerator (uint3 id : SV_DispatchThreadID)
{
        float2 uvheight = 0.0f;
        float2 uv = 0.0f;

        uvheight.x = (id.x * _Step * heightmapWidth / _rootSize + heightmapSampleOffsetX) / heightmapWidth;
        uvheight.y = (id.y * _Step * heightmapHeight / _rootSize + heightmapSampleOffsetY) / heightmapHeight;
        uv.x = id.x * _Step / _Size;
        uv.y = id.y * _Step / _Size;

        float alphaValue = _PositionMap.SampleLevel(my_linear_clamp_sampler, uv , 0).a;

        if(alphaValue > 0.1f) {    // Only display grass where there is alpha map

            // Calculate the actual world position
            float Xoffset = rand(id.xy) *_OffsetXAmount; 
            float Yoffset = rand(id.xy) *_OffsetYAmount;
           
            float3 pos =  0.0f;
            pos.x = _NodePositionX + id.x * _Step - _Size * 0.5f + Xoffset;
            pos.z = _NodePositionY + id.y * _Step - _Size * 0.5f + Yoffset;

            // Sample & set the height
            float4 displacement = _HeightMap.SampleLevel(my_linear_repeat_sampler, uvheight, 0); 
            pos.y = displacement.r * _HeightDisplacementStrenght + 0.01f;

            float3 scale = {1, alphaValue, 1};

            GrassData gd = {pos, scale};

            // Add all information to the outputbuffer
            _GrassData.Append(gd);
        }
}

