// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ApplyDirectionalMotor

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

RWTexture3D<float> _velocitySourcesX;
RWTexture3D<float> _velocitySourcesY;
RWTexture3D<float> _velocitySourcesZ;

float _motorStrenght;
float3 _motorDirection;
float _directionRandomness;
float3 _motorPosWS;
float _motorRadius;

float3 _gridDisplacement;

float _deltaTime;


float rand(float2 co) 
{
    return(frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453)) * 1;
}

[numthreads(8,8,8)]
void ApplyDirectionalMotor (uint3 id : SV_DispatchThreadID)
{
    float3 cellPosition = id - _gridDisplacement;
    float dist = length(cellPosition - _motorPosWS); // from GDC Talk at: "https://youtu.be/dDgyBKkSf7A?t=716"

    if(dist < _motorRadius)
    {
        float3 newDirection = float3(_motorDirection.x + (rand(id.xy) * 2 - 1) * _directionRandomness,
                                     _motorDirection.y + (rand(id.xy) * 2 - 1) * _directionRandomness,
                                     _motorDirection.z + (rand(id.xy) * 2 - 1) * _directionRandomness);

        float3 addedForce = float3(newDirection  * _motorStrenght * _deltaTime);
        _velocitySourcesX[id] += addedForce.x;
        _velocitySourcesY[id] += addedForce.y;
        _velocitySourcesZ[id] += addedForce.z;
    }
}
