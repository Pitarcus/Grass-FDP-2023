// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ForceGPUFluidSim3D
#pragma kernel AdvectionGPUFluidSim3D
#pragma kernel PoissonSolver3D
#pragma kernel Divergence3D
#pragma kernel Gradient3D
#pragma kernel Subtract3D
#pragma kernel BoundaryGPUFluidSim3D
#pragma kernel Copy_StructuredBuffer

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;


// Force
RWStructuredBuffer<float3> velocityBuffer;
StructuredBuffer<float3> prevVelocityBuffer;
StructuredBuffer<float3>  velocitySourcesBuffer;


// AdvectionGPUFluidSim3D
StructuredBuffer<float3> velocityField;
RWStructuredBuffer<float3> newQuantity;
StructuredBuffer<float3> prevQuantity;

float _viscosity;
float _alpha;    // size of the grid cell squared / viscosity * deltaTime 
float _beta;     // beta number of neighbour values (6) +  alpha


// PoissonSolver3D
StructuredBuffer<float3>  bPoisson;  // b aka the copy of the prevVelocityBuffer
StructuredBuffer<float3>  x; // x (changes each iteration of the poisson solver)
RWStructuredBuffer<float3>  jacobiResult;


//Divergence3D
StructuredBuffer<float3> field; // prevVelocityBuffer
RWStructuredBuffer<float3> divergenceField; // velocityBuffer
float _gridCellSize;

// Gradient3D
StructuredBuffer<float3> inputFieldGradient;
RWStructuredBuffer<float3> gradientField;

// Subtract3D
StructuredBuffer<float3> a;
StructuredBuffer<float3> b;
RWStructuredBuffer<float3> subtractResult;

// Copy_StructuredBuffer
StructuredBuffer<float3>   _Copy_Source;
RWStructuredBuffer<float3> _Copy_Target;

// BoundaryGPUFluidSim3D
RWStructuredBuffer<float3> newBoundary;
StructuredBuffer<float3> prevBoundary;
//float3 offset;
int boundaryCondition;

// General
uint _numberOfVoxels;
uint _sizeX;    // It is really, the size - 2 (last voxel not in the boundary)
uint _sizeY;
uint _sizeZ;

float deltaTime;




//  ------- FUNCTIONS -------

uint IndexFrom3DCoord(uint x, uint y, uint z) 
{
    return x + y * (_sizeX+2) + z * (_sizeX+2) * (_sizeY+2);
}

[numthreads(8,8,8)]
void ForceGPUFluidSim3D(uint3 id : SV_DispatchThreadID) 
{
    uint voxelIndex = IndexFrom3DCoord(id.x, id.y, id.z);
    if(voxelIndex < _numberOfVoxels) 
    {
        float3 sourceForce = velocitySourcesBuffer[voxelIndex];
        if (sourceForce.x != 0 && sourceForce.y != 0 && sourceForce.z != 0) 
        {
            velocityBuffer[voxelIndex] =  sourceForce;// prevVelocityBuffer[voxelIndex] + sourceForce; //+ gravityForce;
        }
        else if(prevVelocityBuffer[voxelIndex].x != 0 && prevVelocityBuffer[voxelIndex].y != 0 && prevVelocityBuffer[voxelIndex].z != 0)
        {
            velocityBuffer[voxelIndex] = prevVelocityBuffer[voxelIndex]; //+ gravityForce
        }
        else 
        {
            velocityBuffer[voxelIndex] = 0;
        }
    }
}

[numthreads(8,8,8)]
void AdvectionGPUFluidSim3D(uint3 id : SV_DispatchThreadID) 
{
    int currIndex = IndexFrom3DCoord(id.x, id.y, id.z);
    float3 prevPos = id - velocityField[currIndex] * deltaTime;

    // Making sure the position is inside of the grid
    if (prevPos.x < 0.5f)
        prevPos.x = 0.5f;
    if (prevPos.x > _sizeX + 0.5f)
        prevPos.x = _sizeX + 0.5f;

    if (prevPos.y < 0.5f)
        prevPos.y = 0.5f;
    if (prevPos.y > _sizeY + 0.5f)
        prevPos.y = _sizeY + 0.5f;

    if (prevPos.z < 0.5f)
        prevPos.z = 0.5f;
    if (prevPos.z > _sizeZ + 0.5f)
        prevPos.z = _sizeZ + 0.5f;


    // Trilinear interpolation of the quantity in the previous position
    float3 p1 = floor(prevPos);
    float3 p2 = p1 + 1;

    // Left Bottom Front voxel
    float3 Q1 = prevQuantity [ IndexFrom3DCoord (p1.x, p1.y, p1.z) ];
    // Left Top Front voxel
    float3 Q2 = prevQuantity [ IndexFrom3DCoord (p1.x, p2.y, p1.z) ];
    // Left Bottom Back voxel
    float3 Q3 = prevQuantity [ IndexFrom3DCoord (p1.x, p1.y, p2.z) ];
    // Left Top Back voxel
    float3 Q4 = prevQuantity [ IndexFrom3DCoord (p1.x, p2.y, p2.z) ];
    // Right Bottom Front voxel
    float3 Q5 = prevQuantity [ IndexFrom3DCoord (p2.x, p1.y, p1.z) ];
    // Right Top Front voxel
    float3 Q6 = prevQuantity [ IndexFrom3DCoord (p2.x, p2.y, p1.z) ];
    // Right Bottom Back voxel
    float3 Q7 = prevQuantity [ IndexFrom3DCoord (p2.x, p1.y, p2.z) ];
    // Right Top Back voxel
    float3 Q8 = prevQuantity [ IndexFrom3DCoord (p2.x, p2.y, p2.z) ];

    // ratio ... how much take from a quantity
    float3 t = prevPos - p1;

    // Interpolation in Y direction
    float3 QY1 = (1 - t.y) * Q1 + Q2 * t.y;
    float3 QY2 = (1 - t.y) * Q3 + Q4 * t.y;
    float3 QY3 = (1 - t.y) * Q5 + Q6 * t.y;
    float3 QY4 = (1 - t.y) * Q7 + Q8 * t.y;
    // Interpolation in Z direction
    float3 QZ1 = (1 - t.z) * ( QY1 ) + (QY2) * t.z;
    float3 QZ2 = (1 - t.z) * ( QY3 ) + (QY4) * t.z;
    // Interpolation in X direction
    float3 finalQuantity = (1 - t.x) * ( QZ1 ) + ( QZ2 ) * t.x;

    newQuantity[currIndex] = finalQuantity;
}

[numthreads(8,8,8)]
void PoissonSolver3D(uint3 id : SV_DispatchThreadID) 
{
    int currIndex = IndexFrom3DCoord (id.x, id.y, id.z);
    int leftIndex = IndexFrom3DCoord (id.x - 1 , id.y, id.z);
    int rightIndex = IndexFrom3DCoord (id.x + 1 , id.y, id.z);
    int topIndex = IndexFrom3DCoord (id.x, id.y + 1 , id.z);
    int bottomIndex = IndexFrom3DCoord (id.x, id.y - 1 , id.z);
    int frontIndex = IndexFrom3DCoord (id.x, id.y, id.z + 1);
    int backIndex = IndexFrom3DCoord (id.x, id.y, id.z - 1);
   

    // Jacobi
    jacobiResult[currIndex] = (bPoisson[ leftIndex ] + bPoisson[ rightIndex ] +
    bPoisson[ topIndex ] + bPoisson[ bottomIndex ] + bPoisson[ frontIndex ] +
    bPoisson[ backIndex ] + x[ currIndex ] * _alpha ) / _beta;   
}

[numthreads(8,8,8)]
void Divergence3D(uint3 id : SV_DispatchThreadID) 
{
    int currIndex = IndexFrom3DCoord (id.x, id.y, id.z);
    int leftIndex = IndexFrom3DCoord (id.x - 1 , id.y, id.z);
    int rightIndex = IndexFrom3DCoord (id.x + 1 , id.y, id.z);
    int topIndex = IndexFrom3DCoord (id.x, id.y + 1 , id.z);
    int bottomIndex = IndexFrom3DCoord (id.x, id.y - 1 , id.z);
    int frontIndex = IndexFrom3DCoord (id.x, id.y, id.z + 1);
    int backIndex = IndexFrom3DCoord (id.x, id.y, id.z - 1);

    float u = ( field [ rightIndex ].x - field [ leftIndex ].x);
    float v = ( field [ topIndex ].y - field [ bottomIndex ].y);
    float w = ( field [ frontIndex ].z - field [ backIndex ].z);
    float divergence = (u + v + w) / (2 * _gridCellSize );
    divergenceField [ currIndex ] = float3( divergence , 0 , 0);    
}

[numthreads(8,8,8)]
void Gradient3D(uint3 id : SV_DispatchThreadID) 
{
     int currIndex = IndexFrom3DCoord (id.x, id.y, id.z);
    int leftIndex = IndexFrom3DCoord (id.x - 1 , id.y, id.z);
    int rightIndex = IndexFrom3DCoord (id.x + 1 , id.y, id.z);
    int topIndex = IndexFrom3DCoord (id.x, id.y + 1 , id.z);
    int bottomIndex = IndexFrom3DCoord (id.x, id.y - 1 , id.z);
    int frontIndex = IndexFrom3DCoord (id.x, id.y, id.z + 1);
    int backIndex = IndexFrom3DCoord (id.x, id.y, id.z - 1);

    // x is the first component of field that contains divergence value
    float L = inputFieldGradient [ leftIndex ].x;
    float R = inputFieldGradient [ rightIndex ].x;
    float T = inputFieldGradient [ topIndex ].x;
    float B = inputFieldGradient [ bottomIndex ].x;
    float F = inputFieldGradient [ frontIndex ].x;
    float BACK = inputFieldGradient [ backIndex ].x;
    gradientField [ currIndex ] = float3(R-L, T-B, F- BACK ) / (2 * _gridCellSize );
}

[numthreads(8,8,8)]
void Subtract3D(uint3 id : SV_DispatchThreadID) 
{
    int index = IndexFrom3DCoord (id.x, id.y, id.z);
    subtractResult [ index ] = a[ index ] - b[ index ];

    //if(id.z == 0) {
        Result[id.xy] = float4( a[ index ] - b[ index ], 1);
    //}
}

[numthreads(8,8,8)]
void  BoundaryGPUFluidSim3D (uint3 id : SV_DispatchThreadID)  
{
    if(id.x == 0 || id.x == _sizeX + 1 ||
        id.y == 0 || id.y == _sizeY + 1 ||
        id.z == 0 || id.z == _sizeZ + 1 ) 
    {
        float3 offset = 0;
        if(id.x == 0)
            offset = float3(1, 0, 0);
        if(id.x == _sizeX + 1)
            offset = float3(-1, 0, 0);
        if(id.y == 0)
            offset = float3(0, 1, 0);
        if(id.y == _sizeY + 1)
            offset = float3(0, -1, 0);
        if(id.z == 0)
            offset = float3(0, 0, 1);
        if(id.z == _sizeZ + 1)
            offset = float3(0, 0, -1); 

        int currIndex = IndexFrom3DCoord (id.x, id.y, id.z);
        float3 currCoord = float3(id.x, id.y, id.z);
        float3 coord = currCoord + offset;
        int offsetIndex = IndexFrom3DCoord ( coord .x, coord .y,coord .z);
        newBoundary[ currIndex ] = boundaryCondition * prevBoundary[ offsetIndex ];
    }

}

// Copy utility
[numthreads(256,1,1)]
void Copy_StructuredBuffer(uint3 id : SV_DispatchThreadID)
{
    _Copy_Target[id.x] = _Copy_Source[id.x];
} 
