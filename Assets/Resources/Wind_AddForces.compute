// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ForceGPUFluidSim3D

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

RWTexture3D<float4> velocityBuffer;
Texture3D<float4> prevVelocityBuffer;
Texture3D<float4> velocitySourcesBuffer;


//RWStructuredBuffer<float3> velocityBuffer;
//StructuredBuffer<float3> prevVelocityBuffer;
//StructuredBuffer<float3>  velocitySourcesBuffer;

uint _numberOfVoxels;
uint _sizeX;    // It is really, the size - 2 (last voxel not in the boundary)
uint _sizeY;
uint _sizeZ;

uint IndexFrom3DCoord(uint x, uint y, uint z) 
{
    return x + y * (_sizeX+2) + z * (_sizeX+2) * (_sizeY+2);
}

[numthreads(8,8,8)]
void ForceGPUFluidSim3D(uint3 id : SV_DispatchThreadID) 
{
    uint voxelIndex = IndexFrom3DCoord(id.x, id.y, id.z);
    if(voxelIndex < _numberOfVoxels) 
    {
        float4 sourceForce = velocitySourcesBuffer[id];
        if (sourceForce.x != 0 || sourceForce.y != 0 || sourceForce.z != 0) 
        {
            velocityBuffer[id] = sourceForce;// prevVelocityBuffer[voxelIndex] + sourceForce; //+ gravityForce;
            Result[id.xy] = sourceForce;
        }
        else
        {
            velocityBuffer[id] = prevVelocityBuffer[id]; //+ gravityForce
            Result[id.xy] = float4(0, 1, 0, 1);
        }
    }
}
