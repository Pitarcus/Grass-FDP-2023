// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GrassGenerator


// --------------------------- PARAMETERS ----------------------

struct GrassData
{
    float3 position;
    float3 scale;
};

// Texture with the positions of the grass
Texture2D<float4> _PositionMap;
SamplerState sampler_PositionMap;


AppendStructuredBuffer<float3> _Positions;
AppendStructuredBuffer<float> _YScales;

AppendStructuredBuffer<GrassData> _GrassData;

// Local to world matrix
float4x4 _LocalToWorld;

uint _Size; // The size of the chunk of grass on the terrain / 2

uint _Resolution;   // Amount of blades in each axis

float _Step;    // Distance between each blade

float _OffsetXAmount;
float _OffsetYAmount;

// Height displacement stuff
Texture2D<float4> _HeightMap;
SamplerState sampler_HeightMap;

float _HeightDisplacementStrenght;


// ---------------------------- FUNCTIONS -------------------------


// Random generator
float rand(float2 co) 
{
    return(frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453)) * 1;
}

void SetPosition (uint3 id) 
{
    if (id.x < _Resolution && id.y < _Resolution) 
    {
        float Xoffset = rand(id.xy) *_OffsetXAmount;
        float Yoffset = rand(id.xy) *_OffsetYAmount;

        float3 pos =  0.0f;
        pos.x = id.x * _Step - _Size * 0.5 + Xoffset;
        pos.z = id.y * _Step - _Size * 0.5 + Yoffset;
        
        float2 uv = pos.xz;
        uv.xy -= _Size * 0.5;
        uv.xy /= _Size;

        //uv.y = 1 - uv.y;
        //uv.x = 1 - uv.x;

        /*float2 uv = pos.xz;
        uv = (id.xy) * _Step;
        uv.xy /= float(_Resolution) * _Step;
       // uv.y = 1 - uv.y;
        //uv.x = 1 - uv.x;*/

        float4 displacement = _HeightMap.SampleLevel(sampler_HeightMap, uv, 0); 

        pos.y = displacement.r * _HeightDisplacementStrenght ;

        //_Positions[id.x + id.y * _Resolution] = pos;
    }
}


void SetPositionsWithTexture(uint3 id) {

    if (id.x < _Resolution && id.y < _Resolution) 
    {
        float2 uv = 0.0f;
        uv.x = ((id.x * _Step) % _Size) / _Size;
        uv.y = ((id.y * _Step) % _Size) / _Size;

        if(_PositionMap.SampleLevel(sampler_PositionMap, uv , 0).a > 0.1f) {    // Only display grass where there is alpha map

             // Calculate the actual world position
            float Xoffset = rand(id.xy) *_OffsetXAmount;
            float Yoffset = rand(id.xy) *_OffsetYAmount;
           
            float3 pos =  0.0f;
            pos.x = id.x * _Step - _Size * 0.5f + Xoffset;
            pos.z = id.y * _Step - _Size * 0.5f + Yoffset;

            // Sample & set the height
            float4 displacement = _HeightMap.SampleLevel(sampler_HeightMap, uv, 0); 
            pos.y = displacement.r * _HeightDisplacementStrenght + 0.05f;

            //_Positions.Append(pos);
            //_YScales.Append(_PositionMap.SampleLevel(sampler_PositionMap, uv , 0).a);
            float3 scale = {1, _PositionMap.SampleLevel(sampler_PositionMap, uv , 0).a, 1};

            GrassData gd = {pos, scale};

            _GrassData.Append(gd);
        }
    }
}
    
[numthreads(64,1,1)]
void GrassGenerator (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    //SetPosition(id);

    //SourceVertex sourceVertex = _SourceVertices[id.x];
    //float3 positionWS = mul(_LocalToWorld, float4(sourceVertex.positionOS, 1)).xyz;
    //_Positions.Append(positionWS);

    SetPositionsWithTexture(id);

}
